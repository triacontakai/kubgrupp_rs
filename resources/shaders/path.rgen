#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_ray_tracing : enable

#include "ray_common.glsl"
#include "raygen_common.glsl"
#include "random.glsl"

#define MIS

layout(location = 0) rayPayloadEXT RayPayload ray_info;

const uint MAX_DEPTH = 8;
const uint SPP = 4;
const float T_MIN = 0.0001;
const float T_MAX = 1000.0;

float power_heuristic(float a, float b) {
    float t = a * a;
    return t / (b * b + t);
}

void main() {
    ray_info.seed = tea(gl_LaunchIDEXT.xy + frame * gl_LaunchSizeEXT.xy + seed_offset);

    const uint ray_flags = gl_RayFlagsOpaqueEXT;

    vec3 result = vec3(0);

    for (uint i = 0; i < SPP; i++) {
        vec2 jitter = vec2(rnd(ray_info.seed), rnd(ray_info.seed));
        const vec2 pixel_center = vec2(gl_LaunchIDEXT.xy) + jitter;
        const vec2 in_uv = pixel_center / vec2(gl_LaunchSizeEXT.xy);

        vec2 d = in_uv * 2.0 - 1.0;

        vec4 origin = view_inverse * vec4(0, 0, 0, 1);
        vec4 target = proj_inverse * vec4(d.x, d.y, 1, 1);
        vec4 direction = view_inverse * vec4(normalize(target.xyz), 0);

        vec3 ray_o = origin.xyz;
        vec3 ray_d = direction.xyz;

        vec3 throughput = vec3(1);
        float prev_brdf_pdf;

        bool specular_reflection = true;

        for (uint depth = 0; depth < MAX_DEPTH; depth++) {
            traceRayEXT(
                tlas,
                ray_flags,
                0xFF,
                0,
                0,
                0,
                ray_o,
                T_MIN,
                ray_d,
                T_MAX,
                0
            );

            if (!ray_info.is_hit)
                break;

            if (ray_info.is_emitter) {
                if (specular_reflection) {
                    result += throughput * ray_info.rad;
                } else {
#ifdef MIS
                    vec3 dist_vec = ray_info.hit_pos - ray_o;
                    float dist_sq = dot(dist_vec, dist_vec);
                    float emitter_pdf = ray_info.emitter_pdf * dist_sq / abs(dot(ray_info.hit_normal, ray_d));
                    float mis_weight = power_heuristic(prev_brdf_pdf, emitter_pdf);
                    result += throughput * mis_weight * ray_info.rad;
#endif
                }
                break;
            }

            ray_o = ray_info.hit_pos;
            ray_d = ray_info.brdf_d;
            vec3 obj_pos = ray_info.hit_pos;
            vec3 obj_geo_normal = ray_info.hit_geo_normal;
            vec3 brdf_vals = ray_info.brdf_vals;
            vec3 emitter_brdf_vals = ray_info.emitter_brdf_vals;
            vec3 emitter_normal = ray_info.emitter_normal;
            vec3 emitter_o = ray_info.emitter_o;
            float emitter_pdf = ray_info.emitter_pdf;
            float emitter_brdf_pdf = ray_info.emitter_brdf_pdf;
            vec3 emitter_rad = ray_info.rad;
            vec3 dist_vec = emitter_o - obj_pos;
            specular_reflection = ray_info.is_specular;
            prev_brdf_pdf = ray_info.brdf_pdf;

            if (!specular_reflection) {
                vec3 toward_emitter = normalize(dist_vec);
                float emitter_dist_sq = dot(dist_vec, dist_vec);
                float emitter_dist = sqrt(emitter_dist_sq);

                float cos_em = dot(emitter_normal, -toward_emitter);
                float cos_obj = dot(obj_geo_normal, toward_emitter);
                if (cos_em > 0.0 && cos_obj > 0.0) {
                    const uint shadow_flags = gl_RayFlagsTerminateOnFirstHitEXT
                                            | gl_RayFlagsSkipClosestHitShaderEXT
                                            | gl_RayFlagsOpaqueEXT;
                    ray_info.is_hit = true;
                    traceRayEXT(tlas, shadow_flags, 0xFF, 0, 0, 0,
                                obj_pos, T_MIN, toward_emitter, emitter_dist - T_MIN, 0);

                    if (!ray_info.is_hit) {
                        float g = cos_obj * cos_em / emitter_dist_sq;
#ifdef MIS
                        float converted_pdf = emitter_pdf * emitter_dist_sq / cos_em;
                        float mis_weight = power_heuristic(converted_pdf, emitter_brdf_pdf);
                        result += throughput * mis_weight * g * emitter_rad * emitter_brdf_vals / emitter_pdf;
#else
                        result += throughput * g * emitter_rad * emitter_brdf_vals / emitter_pdf;
#endif
                    }
                }
            }

            throughput *= brdf_vals;
        }
    }
    result /= float(SPP);

    vec3 rad = frame > 0 ? imageLoad(accum_image, ivec2(gl_LaunchIDEXT.xy)).rgb : vec3(0);
    rad += result;
    imageStore(accum_image, ivec2(gl_LaunchIDEXT.xy), vec4(rad, 1.0));

    result = rad / (frame + 1.0);

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(result, 1.0));
}
